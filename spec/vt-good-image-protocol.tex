% vim:cc=80:cole=0
\documentclass[a4paper]{article}
%\documentclass[a4paper, 20pt]{extreport}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\usepackage{colortbl}
\usepackage{todonotes}

\usepackage[hidelinks]{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan
}

% \usepackage{fancyhdr}
% \usepackage{graphicx}

\usepackage{draftwatermark}
\SetWatermarkText{Draft}
\SetWatermarkScale{4}

\usepackage[english]{babel}

\usepackage{xcolor}
\definecolor{light-gray}{gray}{0.95}

\usepackage{geometry}
\geometry{legalpaper, margin=1in}

\title{VT Good Image Protocol \\
a standardization proposal}
\author{Christian Parpart}
% \date{2020-12-18 (draft, revision 0)}
\date{\today \quad (draft, revision 0)}

\newcommand{\code}[1]{\colorbox{light-gray}{\texttt{#1}}}

\newcommand{\DA}{\code{DA1}}
\newcommand{\DECRQM}[1]{\code{CSI ? #1 \$ p}}
\newcommand{\DECRST}[1]{\code{CSI ? #1 l}}
\newcommand{\DECSET}[1]{\code{CSI ? #1 h}}

\newcommand{\GoodImageProtocol}{\code{Good Image Protocol}}

\begin{document}

\maketitle

\tableofcontents

%\newpage

\section{Motivation} % {{{

For many decades Sixel and ReGIS have been the only image protocols for terminal emulators.
While both are ancient and not even widely implemented, now people are used
to seeing images and even emoji everywhere.
Those people may eventually touch a virtual terminal emulator and expect it to be no different
than what they are used to from other software systems.

There is a growing interest in displaying images in todays
virtual terminal emulators.

Since these protocols are were not designed with todays needs in mind,
virtual terminal emulator developers have started implementing their own
proprietary protocols for displaying images as Sixel and related
protocols were simply not fullfulling today's needs anymore.

While recent efforts to image protocols are positive, it also leads to fragmentation in the ecosystem
because application developers do not know what to support in case they intend
to display images in their client applications, and even new terminal emulator
developers don't know what protocol to implement.

There is also a recent resurrection of the Sixel bitmap protocol
to be implemented by some terminal emulator
\footnote{Alacritty, Contour, gnome-terminal, iTerm2, wezterm, xterm.js}
and library \footnote{notcurses, libsixel} developers,
however, none of them is 100\% conforming to how Sixel used to work 50 years ago,
as there is no easy way to access the hardware they were implemented on
and also xterm does not implement every aspect of Sixel while existing
documentation on sixel is also leaving too much room for varying interpretation.

This specification attempts to unify all those image protocols and addresses
some of the issues, not as a superset, but rather as a largest common denominator,
with usability, simplicity, and implementation adaptability in mind and
is also an attempt to formalize what was written down in \ref{ref:twg-gip},
which can be seen as a conclusion of many discussions that happened scattered
across different forums on the topic of a future image protocol.

% }}}
\section{Terminology} % {{{
\begin{itemize}
    \item \textbf{screen cell}; a rectanglular area of the screen that can contain a character with
        its graphics rendition or an image fragment
    \item \textbf{image fragment}; a rectanglular tile of an image that perfectly fits into a screen cell
    \item \textbf{image storage pool}; a backing store for images received for future operations
\end{itemize}

\todo{more terminology to add?}

% }}}
\section{Prior art and current state} % {{{

Prior art of image protocols for terminals are as follows:

\subsection{Tektronix}

\begin{itemize}
    \item First appeared in 1970s
    \item Tektronix 4010 series was a family of text-and-graphics computer terminals based on storage-tube technology created by Tektronix.
    \item implemented by: xterm
\end{itemize}

\subsection{DEC ReGIS graphics}

\begin{itemize}
    \item First appeared in VT125, in July 1981
    \item vector graphics based
    \item implemented by: xterm
\end{itemize}

\subsection{Sixel graphics}

\begin{itemize}
    \item Sixel grpahics first appeared in LA50 dot-matrix printers (1983) and short after in the VT240 in October 1983.
    \item It is pixel based and positions the graphics cursor in a way it is most optimal for dot printers,
        that could print 6 pixels in height per line.
    \item Specialized image format optimized for 6-pin printers.
    \item Supports scrolling the screen if the image does not fit the current screen.
    \item Supports passing different aspect ratio. This is rarely implemented by virtual terminal emulators though.
    \item Supports endless vertical rendering, e.g. to print seismograph data (rarely implemented by virtual terminal emulators).
    \item Implemented by: xterm, mlterm, contour, wezterm, vte, possibly others.
\end{itemize}

This protocol only understands pixels and thus is dependant on the
configured font size and screen resolution of the terminal, which
terminal emulators seem to have solved differently and therefore cannot
be relied on.

\subsection{Terminology image protocol}

Terminology's image protocol is rather a media transport protocol as it
can also be used to render animations, including videos.

\begin{itemize}
    \item First appeared in june, 2012.
    \item Uses vt sequences inspired by xterm's sequence extensions.
    \item Specification is in the source code repository's \texttt{readme.md} file.
    \item Implemented by: terminology
\end{itemize}

\subsection{iTerm2 image protocol}

\begin{itemize}
    \item First introduced in 2014 with documentation added in 2015.
    \item Can associate a file name (Base64 encoded) to the rendered image.
    \item Image display size can be pixel based as well as cell based.
    \item Also has the ability to address the width and height relative to the terminal window size.
    \item Image data is Base64 encoded.
    \item Any image format that macOS supports is supported by iTerm2's image protocol,
        including PDF, PICT, EPS, or any number of bitmap data formats (PNG, GIF, etc.).
    \item implemented by: iterm, wezterm (partly)
\end{itemize}

The dependency on macOS for supported image formats makes it a little blurry
specification also.

\subsection{DomTerm's inline image support}

\begin{itemize}
    \item Domterm's image support appeared in 2016.
    \item No explicit image protocol but a "insert html"-protocol that does support images.
    \item Specification is in the source code repository's \texttt{readme.md} file.
    \item Implemented by: DomTerm
\end{itemize}

The typical way to insert an image is to insert an HTML \texttt{<img>} element,
with the src attribute using a data: URL scheme,
with the actual data inline as base64.

Any image format supported by the underlying browser engine is allowed.

The \texttt{<img>} element can contain attributes such as width, height, alt
and options to add scrollbars.

The tight integration to the browser makes it hard to be adopted by native
terminals.

\subsection{Kitty image protocol}

\begin{itemize}
    \item First appeared in 2017
    \item Seperates image upload from image display
    \item Can mandate image sizes in pixels as well as in screen cell dimensions.
    \item Images are rendered independantly of text with a specified Z-axis.
    \item Images can be deleted without knowning their names but only by specifying X/Y/Z axis
          and delete all images intersecting these criteria.
    \item Image formats supported are: RGB, RGBA, PNG.
    \item Image data is Base64 encoded.
    \item Supports optionally compressing the image data.
    \item Supports various image data transmission methods:
        \begin{itemize}
            \item inline, as part of the VT sequence
            \item named shared memory
            \item path to local files
        \end{itemize}
    \item Optionally deletes the local file when requested and the file path is in a secure location.
    \item Hard coded image storage pool to 320 MB (per screen buffer).
    \item implemented by: kitty, wezterm (partly)
\end{itemize}

None of the above image protocols are a good candiate. iTerm2's image protocol is very simple and
can be rendered by specifying screen cell sizes instead of relying on pixels, but lacks some
flexibility.

Kitty image protocol on the other hand does provide very good flexibility but is way too complex which
would hinder broader adoptability and conforming implementations, potentially leading to partial
implementations and thus fragmentation.
There is also an added complexity (such as support for Z-axis) and the ability
to send images in a way that does not work trivially when the terminal is
connected to remote clients (such as via SSH). This all seems to hinder
adopting a otherwise very flexible image protocol.

The \GoodImageProtocol specification aims to be future proof with regards to
the young generation of terminal users, as well as being simple enough
to be widely accepted and adopted on the terminal side as well as client side,
yet allowing future extensions to this protocol
without breaking compatibility to existing implementations.

% }}}
\section{Requirements} % {{{

This section lays down the principles and requirements of \GoodImageProtocol.

\begin{enumerate}
    \item \textbf{feature detectability} - the image protocol must be easily detectable with well known techniques.
    \item \textbf{protocol forward-compatibility} - the protocol must be easily extendable in input
        parameters as well as reusability of the image storage pool
        (such as icon-display, desktop-notifications, background images).
    \item \textbf{multiplexer-aware} - multiplexers must be able to fully operate without analyzing the image format.
        it must be possible to blindingly forward the image data to the outputting terminals.
    \item \textbf{deterministic emulation} - the image rendering must not be affected by font size
        or similar properties nor on external api to make productive use of this protocol.
    \item \textbf{synchronous operations by default} - no asynchronous operations unless explicitly requested.
    \item \textbf{preserve aspect ratio by default}
    \item \textbf{remote-terminal capable} - no dependency on the local host, such as the local file system.
    \item \textbf{upload and render seperation} - image upload must be decoupled from image display
    \item \textbf{support for rendering tiles of an image} - adding the ability to only render tiles
        of an image greatly assists client applications when only rendering parts of an image is
        needed (such as in multiplexers).
\end{enumerate}

\paragraph*{}

The document at [\ref{ref:twg-gip}] suggests cell based masking for rendering to help rendering more
complex scenes such as in windowed TUI applications or terminal multiplexers with overlaying contents.
However, the same can be achieved with a sequence of Image-Render commands specifying a
sub-rectangle (tiles) to be rendered of the referenced image.

% }}}
\section{Backwards Compatibility} % {{{

Since all other image protocols are pixel based, the proposed image protocol does not
attempt to retain any backwards compatibility. Instead, the goal is to create
an image protocol that is future proof with todays needs in mind.

% }}}
\section{Future Compatibility and Stability} % {{{

In order to leave room for improvements, the VT sequences should be designed in a way
that allows specifying additional parameters in the future, and simultaneously ensures
that older implementations can still work while safely ignoring any new parameters.

% }}}
\section{Terminal Emulator Requirements} % {{{

This is the list of resource requirements that must be guaranteed
by the virtual terminal emulator.

\begin{enumerate}
    \item at least 64 images concurrently
    \item at least 4 MB per image uncompressed (RGBA8888)
\end{enumerate}

Upper limits must be present for security reasons but can be varying by implementation.

% }}}
\section{Performance Considerations} % {{{

\todo{performance considerations on the backend side as well as rendering}

tbd.

% }}}
\section{Security Considerations} % {{{

\begin{itemize}
    \item image upload spamming - should be avoidable by a meaningful limit
        on how many images can be uploaded at the same time.
        Exceeding the limit will result in evicting ideally older images,
        leading to dangling image fragments, as their related image has been
        evicted. A placeholder or an empty screen cell may be displayed instead or no image at all.
    \item huge image uploads - must be avoidable by limiting the number
        of pixels an image can take.
    \item invalid image uploads - a terminal proxy (such as tmux) do not
        implicitly need to validate image formats as they are usually just
        forwarding the blobs to the connected terminal. A non-proxying
        terminal however will validate implicitly by loading the specified
        file format.
    \item invalid image render requests (such as out of bounds in offsetted-renders) -
        invalid named images will not be displayed.
        Overextending dimensions will be displayed but result in cut-of images.
\end{itemize}

% }}}
\section{Semantics} % {{{
\subsection{The lifecycle of an image} % {{{

While classically it should be allowed to just display images,
with having the cursor moved, and forget about that one has rendered that
image, it must also be possible to render the same image multiple times
in an resource efficient time.

Therefore, the concept of image display is broken up into multiple parts,
by separating the image upload from rendering, so
that the same image data can be reused in multiple render commands with
the choice of either drawing the full image or just parts of it.
The latter is important for toolkit developers to efficiently redraw
patially overlapping images.

\subsubsection*{Uploading the image} % {{{

The command for uploading the image simply uploads the image.
In order to make use of that previously uploaded image, a application-specific
fully qualifying (and ideally unique) name is being passed.
This name can be used in future commands to render, rerender the image
either in its whole or parts of it.

The link between the name and the uploaded image can be explicitly released,
and then be reused by other image uploads while prior image uploads to that
name are preserved.

The image upload does not generate any visible output, but may optionally
(not by default) reply to the application a success indication.

% }}}
\subsubsection*{Rendering the image} % {{{

Rendering the image is done by referencing the previously uploaded
image by its name and then telling the command where to render it
in screen coordinates, with number of columns and number of lines to fill
with that image. This can be seen similar to the `DECFRA` VT sequence
that also fills a rectangular region with a fixed SGR, except
that this command filles the rectangular area with an image instead.

% }}}
\subsubsection*{Releasing the image} % {{{

When the image's referenced name is not needed anymore it must be released.
This does not implicitly erase already rendered screen areas referencing the image.
It purely disassociates the name with the image, eventually leading
to resource eviction when no screen cell is holding a reference to the
uploaded image anymore.

% }}}
\subsubsection*{Rendering the image only once} % {{{

While the above is sufficient to efficiently operate with images in the terminal,
there are usecases where an image needs to be rendered exactly once and
seperating upload, render, and release stages is therefore unnecessary,
such as simply putting the image onto the screen and have the cursor moved
accordingly, so that it perfectly fits into the command flow of your primary screen.

\textbf{iTerm2} is having such a special command, called \code{imgcat},
there is also \code{lsix} to display images in the spirit of \code{ls},
and there are similar tools for kitty's and terminology's protocol, too.

\GoodImageProtocol must provide a command to make it trivial for application
developers to achieve the same.

% }}}

% }}}
\subsection{Feature Detection} % {{{

\DA is already used to advertise terminal features, including Sixel graphics, and thus,
\DA is also used to advertise \GoodImageProtocol support, for consistency.

There is some improved feature detection specification work ongoing\todo{reference missing},
so there may be other ways to detect \GoodImageProtocol in the future, when that is ready.

% }}}
\subsection{Querying Resource Limits} % {{{

Resource limits must be queryable whilest the requirements must be met.
Every resource requirement also has a limit at exactly
the value of the requirement or above, and must be queryable

\begin{itemize}
    \item number of images displayable concurrently (visible or not visible)
        A recommendation for this limit is 128 on terminals running on desktop computers.
    \item number of bytes an the image data must not exceed in its respective image format.
    \item maximum width and height for images.
\end{itemize}

% }}}
\subsection{Upload Image} % {{{

Uploads an image for future render operations.

\subsubsection*{Parameters}

\begin{tabular}{|m{3cm}|m{12cm}|}
  \hline
  \textbf{parameter name} & \textbf{description} \\
  \hline
  \textbf{name}           & a unique identifier for the uploaded image \\
  \textbf{format}         & a value that determines the image format. \\
                          & See section \ref{sec:supported-image-formtats} for available image formats \\
  \textbf{width}          & optional pixel width of the given image
                            (only required if this information is not provided
                            inline via the \textbf{data} field) \\
  \textbf{height}         & optional pixel height of the given image
                            (only required if this information is not provided
                            inline via the \textbf{data} field) \\
  \textbf{data}           & image data in the specified input format \\
  \hline
\end{tabular}

\subsubsection{Idempotency}

Image upload can be implemented to be idempotent, but doesn't have to,
i.e. the storage pool keeps an internal hash of each image that is
automatically constructed upon image upload.

If the image was already uploaded, that image's reference count is incremented
and in case it is a named resource, that one will point to that existing one.

% }}}
\subsection{Render Image} % {{{

Renders an image that has been previously uploaded.
The image will be rendered with the top-left matching the current ansi cursor position.
The cursor will not be moved by this operation.

\subsubsection*{Parameters}

\begin{tabular}{|m{3cm}|m{2cm}|m{10cm}|}
    \hline
    \textbf{parameter name}   & \textbf{default} & \textbf{description} \\
    \hline
    \textbf{name}             &                  & unique identifier referencing a previously uploaded image \\
    \textbf{screen-rows}      &                  & number of screen cells to render horizontally \\
    \textbf{screen-cols}      &                  & number of screen cells to render vertically \\
    \textbf{screen-layer}     & above            & render image below text (0), replace text (1), above text (2) \\
    \textbf{resize-policy}    & noresize         & optional, mandates how to resize the image within the screen cells \\
    \textbf{alignment-policy} & middlecenter     & optional, mandates how to align the image within the screen cells \\
    \textbf{image-x-offset}   & 0                & start rendering at the given pixel x-offset cell of the image \\
    \textbf{image-y-offset}   & 0                & start rendering at the given pixel y-offset cell of the image \\
    \textbf{image-width}      & auto-max         & optional, number of pixels of the image's width to display \\
    \textbf{image-height}     & auto-max         & number of pixels of the image's height to display \\
    \textbf{update-cursor}    & false            & optional, tells the terminal to move the text cursor after having the image rendered (image left aligned) below the image \\
    \textbf{request-status}   & false            & request a success/failure status response code from the terminal \\
                              &                  & if value is true, a response is sent back to the application \\
                              &                  & to indicate success or failure. \\
                              &                  & if value is set to false (or parameter is not present), \\
                              &                  & no response is sent back to the application. \\
    \hline
\end{tabular}

% \paragraph*{}
% If parameter \textbf{screen-width} and \textbf{screen-height} are both omitted (or set to 0), then the
% number of screen cells will be automatically determined.

\paragraph*{}
if one of the parameters \textbf{screen-width} and \textbf{screen-height}
is present and the other is missing, the missing one will be automatically
determined by preserving the aspect ratio.

\paragraph*{}
Rendered images that produce a padding due to alignment- and resize-policy
will fill the gap with the currently active sgr background color.

\paragraph*{}
Reverse video mode mode (\code{decscnm}) will affect the padding color but not the image.

\subsubsection*{Resize Policy}

\begin{tabular}{ |l|l| }
    \hline
    \textbf{Name}          & \textbf{Description} \\
    \hline
    NoResize      & Does not perform any resize, leading to a padding on one or two sides \\
                  & as mandated by the alignment-policy. \\
    ResizeToFit   & Resizes the image to fit the specified screen width and height, \\
                  & leading to a padding on zero or one sides as mandated by the alignment-policy. \\
    ResizeToFill  & Resizes the image to fill the specified screen width and height, \\
                  & preserving the aspect ratio, leading to potential clipping depending on the \\
                  & alignment-policy. \\
    StretchToFill & Resizes the image to fill the specified screen width and height, \\
                  & ignoring the aspect ratio, ignoring alignment-policy. \\
    \hline
\end{tabular}

\subsubsection*{Alignment Policy}

\begin{tabular}{ |l|l| }
    \hline
    \textbf{Name}          & \textbf{Description} \\
    \hline
    TopCenter     & The image is aligned vertically on the top and horizontally in the center of the screen. \\
    TopStart      & The image is aligned vertically on the top and horizontally on the left. \\
    TopEnd        & The image is aligned vertically on the top and horizontally on the right. \\
    \hline
    MiddleCenter  & The image is aligned vertically and horizontally in the center of the screen. \\
    MiddleStart   & The image is aligned vertically centered and horizontally on the left. \\
    MiddleEnd     & The image is aligned vertically centered and horizontally on the right. \\
    \hline
    BottomCenter  & The image is aligned vertically on the bottom and horizontally in the center of
    the screen. \\
    BottomStart   & The image is aligned vertically on the bottom and horizontally on the left. \\
    BottomEnd     & The image is aligned vertically on the bottom and horizontally on the right. \\
    \hline
\end{tabular}

% }}}
\subsection{Upload and Render Image} % {{{

This uploads and renders the image via a single VT sequence. Therefore no image Id
is required and there won't be any way to reference that image after either.

The parameters of this function is the sum of the image upload and image render parameters excluding the unique
identifier and excluding sub-rectangle rendering parameters.

The image will be rendered with the top-left matching the current ANSI cursor position.
The cursor will not be moved by this operation.

\subsubsection*{Parameters}

\begin{tabular}{|m{3cm}|m{2cm}|m{11cm}|}
    \hline
    \textbf{parameter name} & \textbf{default} & \textbf{description} \\
    \hline
    \textbf{screen-rows}      &                  & number of screen cells to render horizontally \\
    \textbf{screen-cols}      &                  & number of screen cells to render vertically \\
    \textbf{resize-policy}    & noresize         & optional, mandates how to resize the image within the screen cells \\
    \textbf{alignment-policy} & middlecenter     & optional, mandates how to align the image within the screen cells \\
    \textbf{image-x-offset}   & 0                & start rendering at the given pixel x-offset cell of the image \\
    \textbf{image-y-offset}   & 0                & start rendering at the given pixel y-offset cell of the image \\
    \textbf{image-format}     &                  & a value that determines the image format. \\
                              &                  & see section \ref{sec:supported-image-formtats} for available image formats \\
    \textbf{image-width}      & auto-max         & optional, number of pixels of the image's width to display \\
    \textbf{image-height}     & auto-max         & number of pixels of the image's height to display \\
    \textbf{image-data}       &                  & image data in the specified input format \\
    \textbf{update-cursor}    & false            & optional, tells the terminal to move the text cursor after having the image rendered (image left aligned) below the image \\
    \textbf{auto-scroll}      &                  & boolean, indicating whether or not the page is beign scrolled up \\
                              &                  & if the image would not fit otherwise \\
    \hline
\end{tabular}

\todo{specify how auto-scroll can be achieved in primary screen for render and upload-and-render actions.}

\paragraph{*}
in primary screen, if rendering the image would render below the main page area,
the screen is scrolled up accordingly to ensure the bottom of the image can still be seen.
this may cause the top of the image to be moved into the scrollback area
if the image to be rendered is larger than the main page's line count.

% }}}
\subsection{Release Image} % {{{

Removes the mapping of the name to the image in a storage pool.
This will cause decrementing the use-count of the previously uploaded image.
Existing rendered images are not affected by this operation.

\subsubsection*{parameters}

\begin{tabular}{|l|l|l|}
    \hline
    \textbf{parameter name} & \textbf{default} & \textbf{description} \\
    \hline
    \textbf{name}           &                  & the unique identifier of the uploaded image. \\
    \hline
\end{tabular}

% }}}
\subsection{Storage Management} % {{{

Uploaded images are reference counted.
Uploading a named image will associate the uploaded image with the specified
name and initialize the image's reference count to 1.

When uploading an image would exceed the storage pool limits,
the host may choose to actively evict images.

The recommendation here is to use FIFO for eviction,
but this is not a mandatory algorithm.
If a terminal author comes with a much smarter eviction policy implementation,
that should not in FIFO-order until the new image fits.

If the image is larger than the allowed storage size, the upload will fail.

Evicted images that were still held in screen cells will
either display a image placeholder or an empty screen cell, neither
is mandatory and free to chose by the terminal author.

Displaying an image results in incrementing the reference counter
by the number of screen cells that are holding fragments of the image.

Clearing a screen cell holding an image fragment (e.g. by overwriting
or deleting its contents) will decrement the image reference count of
the prior referenced image.

When no screen cell is holding a reference to the image,
the corresponding reference counter should be either 1 (if uploaded in a separate step)
or 0 (if uploaded within the render instruction).

When the reference count gets down to zero, the image can be safely evicted.

Releasing the image by its name will remove the name-to-image association, and thus,
decrement its reference counter.

Uploading a new image with an already used name will first release the old name-to-image association
as mentioned earlier and then register the new image with its name. This will not cause
any visible side effects - existing image fragments to the old image will not be touched.

% }}}
\subsection{Interoperability with other VT sequences} % {{{

The rendered image can either replace any existing text on the rendered
screen cells, render below or render above of the screen's text.

To retain interop with all existing screen buffer mutating sequences,
any image fragments being associated to a screen cell are strongly bound
to that cell, e.g. when this cell is being moved to the right, the associated
image fragemnt will move to the right, too.

VT sequences that are designed to delete text, will also delete any
associated image fragment data in this screen cell as well.

\subsubsection*{Cursor and margin}

The cursor position respects
\code{DECOM}\footnote{https://www.vt100.net/docs/vt510-rm/DECOM.html}
margin and an image must not leave the current horizontal nor vertical margins
when being rendered.
The image gets clipped if it would render outside the margin.

\subsubsection*{Screen modifying commands}

All existing screen modifying VT sequences preserve their meanings.
That is, commands such as
\code{DECIC}\footnote{https://www.vt100.net/docs/vt510-rm/DECIC.html},
and others will split the image in two halfs.

\subsubsection*{Screen cell characters and image tiles}

Image fragments can be rendered above text, below text, or replace text.

Analogous, when an image is placed into a screen cell that currently holds
an image fragement that is meeant to replace text,
that text will replace the image fragment as well.

\subsubsection*{Image alpha channel and graphics rendition background color}

Images with an alpha channel will blend into the graphics renditions
background color (respecting reverse-video attribute) of that cell analogous
to how padding pixel color is applied for image fragments.

\subsubsection*{Hyperlinks}

If the terminal emulator supports hyperlinks and the application has initiated
a hyperlink, followed by rendering an image, the whole rendered image becomes
hyperlinked, analogous to how hyperlinks are applied to text.

\subsubsection*{Text reflow}

Text reflow is supported only inconsistently across a few terminals.
Therefore this specification does not attempt to address this for images.
Image cells behave just like text cells, potentially wrapping on shrink
and eventually merging back when regrown.

When text reflow is going to be formally specified it must then also address images.

\subsubsection*{Clearing the screen}

VT sequences (such as \code{CSI Ps J}) that reset at least the textual contents
of the screen cells will also clear their image fragment referencing an underlying image,
possibly also releasing the underlying image(s) from the image storage pool
when their reference count has reached zero.

\subsubsection*{Primary and alternate screen}

Alternate screen and primary screen maintain both a shared image storage pool.

% }}}

% }}}
\section{Syntax} % {{{

This section maps each semantic action to actual VT sequences.

Each command is using the \code{OSC} protocol with an embedded message as
described below.

In order to stay consistent to already existing \code{OSC}'s,
the image commands below also reserve a numeric identifier the uniquely
identify the message.

The basic format is as follows:

\code{OSC 314 ; <payload> ST}

\todo{Unfinished text...}

\subsection{Message Format} % {{{

This message format helps sending arbitrary parametrized messages
as payload and is suitable for \code{DCS} and \code{OSC} payloads.

The message format is inspired by and trivialized as basic HTTP message like
format with the following basic rules:

\begin{itemize}
    \item A message is devided into two optional parts, i.e. a set of headers and the body part.
    \item Headers and body are seperated by \code{;}.
    \item Header entries are seperated by \code{,}.
    \item Header name and value is seperated by \code{=}.
    \item Duplicate header names will override the previousely declared ones.
    \item Header value and message body can be optionally Base64 encoded by prepending \\
        an exclamation mark (\code{!}) at the beginning of the header's value or body.
    \item superfluous commas in header seperation are ignored
    \item header names without a value reflect a boolean truth value,
        its \code{=} can therefore be omitted.
\end{itemize}

When this message format is used as payload for \code{OSC} commands, then
the \code{OSC}'s payload will still need to contain the leading numeric
number followed by a semicolon (\code{;}) in order to retain consistency
with existing \code{OSC} implementations.

\subsubsection*{Resource Requirements}

These are the requirements a message parser must be able to process at least.
There should always be a limit, too, which is implicitly at least as big as
the here specified requirements.

Especially the message body might be useful to extend the limit for.

\begin{itemize}
    \item 64 bytes for header name
    \item 512 bytes for header value
    \item 32 header pairs
    \item 16 Megabyte for the body.
\end{itemize}

\subsubsection*{Examples}

\begin{itemize}
    \item \code{first=Foo,second=Bar;some body here}
    \item \code{,first=Foo,second,,,another=value,also=;some body here}
    \item \code{message=!SGVsbG8gV29ybGQ=} (no body, only one Base64 encoded header)
    \item \code{;!SGVsbG8gV29ybGQ=} (no headers, only one Base64 encoded body)
\end{itemize}

% }}}
\subsection{Feature Detection} % {{{

Syntax: \DA

\DA's response code for detecting support for an implementation of this specification is \code{11}.

% }}}
\subsection{Upload Image} % {{{

Syntax: \code{OSC 314 ; u ; <message> ST}

The payload's format is mandated by the \code{fmt}'s value. However, since it must not contain
any C0 or C1 escape codes, the transport is further protected by encoding it via Base64.

\subsubsection*{Parameters}

\begin{tabular}{|m{3cm}|m{2cm}|m{11cm}|}
    \hline
    \textbf{header name}   & \textbf{title}   & \textbf{notes} \\
    \hline
    \textbf{n}             & name             & unique name of the image \\
    \textbf{W}             & width            & number of image width of the uploaded image (not needed for PNG) \\
    \textbf{H}             & height           & number of image height of the uploaded image (not needed for PNG) \\
    \textbf{F}             & format           & enum (see section \ref{sec:supported-image-formtats}) \\
    \hline
\end{tabular}

The message body contains the image data.

\subsubsection*{Example}

This is a small Bash shell example that is uploading a PNG image with a fixed ID.

\begin{verbatim}
    # Shell function demonstrating how to upload an image:
    function gip_upload() {
        local ImageId=$(echo -ne "org.yourdomain.yourtool.$1" | base64 -)
        local ImageData=$(base64 "$2")
        local ImageFormat=3 # 3=PNG
        echo -ne "\033P314;u;F=${ImageFormat},n=${ImageId};!${ImageData}\033\\"
    }
\end{verbatim}

\pagebreak

% }}}
\subsection{Render Image} % {{{

Syntax: \code{OSC 314 ; r ; <message> ST}

\subsubsection*{Message parameters}

\begin{tabular}{|m{3cm}|m{2cm}|m{11cm}|}
    \hline
    \textbf{message header}   & \textbf{title}   & \textbf{Value} \\
    \hline
    \textbf{n} & name             & image Id as string \\
    \textbf{z} & screen-layer     & Render image below text (0), replace text (1), above text (2) \\
    \textbf{L} & screen-left      & screen column of the image's left (if not given, the current ANSI text cursor location is used) \\
    \textbf{T} & screen-top       & screen row of the image's top (if not given, the current ANSI text cursor location is used) \\
    \textbf{c} & screen-cols      & number of columns this image will be printed on \\
    \textbf{r} & screen-rows      & number of rows the image will be printed on \\
    \textbf{x} & image-x-offset   & x-offset into the referenced image in screen coordinates (used to render only parts of the image) \\
    \textbf{y} & image-y-offset   & y-offset into the referenced image in screen coordinates (used to render only parts of the image) \\
    \textbf{w} & image-width      & width of the referenced image in screen coordinates (used to render only parts of the image) \\
    \textbf{h} & image-height     & height of the referenced image in screen coordinates (used to render only parts of the image) \\
    \textbf{R} & resize-policy    & one of: \\ % TODO: defaults should have the lowest value (=> 1)
               &                  & 1 (NoResize), 2 (ResizeToFit), 3 (ResizeToFill), 4 (StretchToFill) \\
    \textbf{a} & alignment-policy & one of: \\
               &                  & 1 (MiddleCenter), 2 (MiddleStart), 3 (MiddleEnd), \\
               &                  & 4 (TopStart), 5 (TopCenter), 6 (TopEnd), \\
               &                  & 7 (BottomStart), 8 (BottomCenter), 9 (BottomEnd) \\
    \textbf{t} & update-cursor    & boolean indicating to move the ANSI text cursor \\
    \textbf{s} & status           & one of: 1 (request status response), 0 otherwise (default) \\
    \hline
\end{tabular}

\subsubsection*{Response Sequence}

When a response status code was requested, the syntax will be as follows:

\begin{tabular}{ |r|l| }
    \hline
    \textbf{VT sequence} & \textbf{description} \\
    \hline
    \code{CSI > 0 i} & Image is rendered successfully \\
    \code{CSI > 1 i} & Image was not rendered. No image with the given Id found. \\
    \hline
\end{tabular}

\subsubsection*{Example}

\begin{verbatim}
    # Shell function demonstrating how to render an image:
    function render_image() {
        # Rendering the given image at the current cursor position with a 20x10 size.
        local ImageId=$(echo -ne "org.binutils.ls.$1" | base64 -)
        local ScreenColumns="20"
        local ScreenLines="10"
        echo -ne "\033P314;r;1;c=${ScreenColumns};r=:${ScreenLines}n=${ImageId}\033\\"
    }
\end{verbatim}

% }}}
\subsection{Upload and Render Image} % {{{

Syntax: \code{OSC 314 ; s ; <payload> ST}

\subsubsection*{Numerical parameters}

\begin{tabular}{|m{3cm}|m{2cm}|m{11cm}|}
    \hline
    \textbf{message header}   & \textbf{title}   & \textbf{Value} \\
    \hline
    \textbf{W} & width            & number of image width of the uploaded image (not needed for PNG) \\
    \textbf{H} & height           & number of image height of the uploaded image (not needed for PNG) \\
    \textbf{F} & format           & enum (see section \ref{sec:supported-image-formtats}) \\
    \hline
    \textbf{z} & screen-layer     & Render image below text (0), replace text (1), above text (2) \\
    \textbf{L} & screen-left      & screen column of the image's left (if not given, the current ANSI text cursor location is used) \\
    \textbf{T} & screen-top       & screen row of the image's top (if not given, the current ANSI text cursor location is used) \\
    \textbf{c} & screen-cols      & number of columns this image will be printed on \\
    \textbf{r} & screen-rows      & number of rows the image will be printed on \\
    \textbf{x} & image-x-offset   & x-offset into the referenced image in screen coordinates (used to render only parts of the image) \\
    \textbf{y} & image-y-offset   & y-offset into the referenced image in screen coordinates (used to render only parts of the image) \\
    \textbf{w} & image-width      & width of the referenced image in screen coordinates (used to render only parts of the image) \\
    \textbf{h} & image-height     & height of the referenced image in screen coordinates (used to render only parts of the image) \\
    \textbf{R} & resize-policy    & one of: \\ % TODO: defaults should have the lowest value (=> 1)
               &                  & 1 (NoResize), 2 (ResizeToFit), 3 (ResizeToFill), 4 (StretchToFill) \\
    \textbf{a} & alignment-policy & one of: \\
               &                  & 1 (MiddleCenter), 2 (MiddleStart), 3 (MiddleEnd), \\
               &                  & 4 (TopStart), 5 (TopCenter), 6 (TopEnd), \\
               &                  & 7 (BottomStart), 8 (BottomCenter), 9 (BottomEnd) \\
    \textbf{t} & update-cursor    & boolean indicating to move the ANSI text cursor \\
    \textbf{s} & status           & one of: 1 (request status response), 0 otherwise \\
    \hline
\end{tabular}

\subsubsection*{Example}

This is a small Bash shell example that is uploading a PNG image with a fixed ID.

\begin{verbatim}
    # Shell function demonstrating how to render a oneshot image:
    function send_image_once() {
        local ImageData=$(base64 "$1")
        local ImageFormat="png"
        local GridWidth="20"
        local GridHeight="10"
        echo -ne "\033P314;s;F:${ImageFormat};c:${GridWidth};r:${GridHeight}s${ImageData}\033\\"
    }
\end{verbatim}

% }}}
\subsection{Release Image} % {{{

Syntax: \code{OSC 314 ; d ; <message> ST}

\subsubsection*{Message parameters}

\begin{tabular}{ |c|c|l| }
    \hline
    \textbf{header name}   & \textbf{title}   & \textbf{notes} \\
    \hline
    \textbf{n}             & name             & unique name of the image \\
    \hline
\end{tabular}

% }}}
% }}}
\section{Supported Image Formats} % {{{

\label{sec:supported-image-formtats}

\begin{tabular}{c | c | l}
    File Format & Identifier     & Description \\
    \hline
    RGB         & \code{rgb}     & raw RGB data with each color component being of size 1 byte. \\
    RGBA        & \code{rgba}    & raw RGBA data, just like RGB, but with an alpha channel. \\
    PNG         & \code{png}     & PNG file format \\
    Sixel       & \code{sixel}   & Payload is given in sixel encoding. \\
    \hline
\end{tabular}

\todo{I think it make sense to use mimetype as values instead?}

% }}}
\section{Future Modifications} % {{{

Possible future modifications could (but do not have to) cover:

\begin{itemize}
    \item Set and reset resource limits.
    \item Query allocated resource names.
    \item Query resource utilization.
    \item Direct support of animations.
    \item Different transport encodings (other than Base64).
    \item Extending the use of uploaded images to also be used for application / window / tab icons.
    \item Extending the use of uploaded images to terminal background.
\end{itemize}

% }}}
\section{References} % {{{

\begin{enumerate}
    \item \label{ref:ctlseqs}\url{https://invisible-island.net/xterm/ctlseqs/ctlseqs.txt}
    \item \label{ref:twg-simple-image-display}Simple Image display, \url{https://gitlab.freedesktop.org/terminal-wg/specifications/-/issues/12}
    \item \label{ref:twg-gip}Good Image Protocol, \url{https://gitlab.freedesktop.org/terminal-wg/specifications/-/issues/26}
    \item \label{ref:image-sixel}Sixel Image Protocol, \url{https://vt100.net/docs/vt3xx-gp/chapter14.html}
    \item \label{ref:image-item2}iTerm2's image protocol, \url{https://iterm2.com/documentation-images.html}
    \item \label{ref:image-terminology}Terminology's image protocol, \url{https://github.com/borisfaure/terminology/blob/master/README.md#available-commands}
    \item \label{ref:image-kitty}Kitty's image protocol, \url{https://sw.kovidgoyal.net/kitty/graphics-protocol.html}
\end{enumerate}

% }}}
\section{Editorial Notes} % {{{

\begin{itemize}
    \item Maybe use tables instead of lists for parameter listings?
    \item Should we mention how to deal with HiDPI displays and content scaling?
    \item How to implement a cat-like tool for images without breaking determinism for proxy
        terminals (like tmux).
        I.e. how does the proxy terminal know about how many rows will be used when
        a pixel perfect rendering is attempted (resize-policy set to NoResize,
        screen-cols=\$COLUMNS). But what is row count?
        I think the only way to achieve that if that image-cat tool peaks into
        the image dimensions and calculates a maybe perfect number of rows
        based on that and the retrieved pixel height (which is not recommended though).
    \item Do we want to deal with transparent pixels differently?
    \item Is it \textbf{really} necessary to be able to render above/below text with preserving the
        text? What is the real use case for that? (that would require the introduction of a z-axis).
    \item If so, can images be layered, therefore can a cell have more than one image.
        And what is happening if the above image is removed. Will the image below be shown?
    \item Should SGRs be usable in screen cells showing image fragments?
\end{itemize}

% }}}

\listoftodos

\end{document}

% vim:ts=4:sw=4
